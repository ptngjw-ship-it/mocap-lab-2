<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jun Wei Biodynamic Lab</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;background:#0f172a;color:#e6eef8;margin:0}
    .app{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:12px}
    .panel{background:#0b1220;padding:12px;border-radius:10px;box-shadow:0 6px 24px rgba(2,6,23,.6)}
    button{width:100%;margin:6px 0;padding:10px;border-radius:8px;border:none;background:#2563eb;color:white;font-weight:800;cursor:pointer}
    button.secondary{background:#475569}
    button.danger{background:#ef4444}
    button.good{background:#22c55e}
    #videoWrap{position:relative}
    video, canvas{width:100%;height:auto;border-radius:10px}
    .small{font-size:12px;color:#9fb5d9}
    label{display:flex;gap:8px;align-items:center;margin:6px 0;color:#cfe6ff;font-size:13px}
    input[type=number], select{
      background:#0b1220;border:1px solid #20314a;padding:8px;border-radius:6px;color:#e6eef8;width:100%
    }
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .status{padding:8px;border-radius:8px;background:rgba(148,163,184,0.12);border:1px solid rgba(148,163,184,0.25)}
    .statusLine{display:flex;justify-content:space-between;gap:10px}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(37,99,235,0.15);border:1px solid rgba(37,99,235,0.35);color:#bfdbfe}
    .pill.warn{background:rgba(234,179,8,0.12);border:1px solid rgba(234,179,8,0.35);color:#fde68a}
    .pill.bad{background:rgba(239,68,68,0.12);border:1px solid rgba(239,68,68,0.35);color:#fecaca}
    table{width:100%;border-collapse:collapse;color:#cfe6ff;margin-top:10px}
    th,td{padding:6px;border-bottom:1px solid rgba(255,255,255,0.06);text-align:left;font-size:12px}
    tr.focused{background:rgba(37,99,235,0.18)}
    .jointGrid{display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:8px}
    .interp{white-space:pre-line;margin:8px 0 0 0;color:#dbeafe;font-size:12px}
    .hint{color:#9fb5d9;font-size:11px;margin-top:6px;line-height:1.35}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel" style="height:calc(100vh - 32px);overflow:auto">
      <h2 style="margin:0 0 8px 0;">Jun Wei Biodynamic Lab</h2>

      <div class="status">
        <div class="statusLine small">
          <div><b>Status:</b> <span id="statusText">Idle</span></div>
          <div class="pill" id="securePill" style="display:none;">HTTPS OK</div>
        </div>
        <div class="statusLine small" style="margin-top:6px;">
          <div><b>Requested FPS:</b> <span id="reqFpsText">120</span></div>
          <div><b>Actual FPS:</b> <span id="actFpsText">--</span></div>
        </div>
        <div class="statusLine small" style="margin-top:6px;">
          <div><b>Loop FPS:</b> <span id="loopFpsText">--</span></div>
          <div><b>Samples:</b> <span id="sampleCount">0</span></div>
        </div>
        <div class="small" id="fpsNote" style="margin-top:6px;color:#9fb5d9;"></div>
      </div>

      <h3 style="margin:14px 0 6px 0;">Camera</h3>

      <div class="small">Request camera FPS</div>
      <select id="fpsRequest">
        <option value="120" selected>120 fps (request)</option>
        <option value="60">60 fps (request)</option>
        <option value="30">30 fps (request)</option>
      </select>

      <button id="startCam">Start camera</button>
      <button id="stopCam" class="secondary">Stop camera</button>

      <button id="exportPNG" class="secondary">Export PNG snapshot (video + overlay)</button>

      <h3 style="margin:14px 0 6px 0;">Recording</h3>
      <div class="row">
        <button id="startRec" class="good">Start record</button>
        <button id="stopRec" class="danger">Stop record</button>
      </div>
      <button id="downloadCSV" class="secondary">Download joint CSV</button>

      <h3 style="margin:14px 0 6px 0;">Anthropometrics</h3>
      <div class="small">Body mass (kg)</div>
      <input id="subjectMass" type="number" value="70" />
      <div class="small" style="margin-top:8px;">Body height (m)</div>
      <input id="subjectHeight" type="number" step="0.01" value="1.75" />
      <div class="row">
        <button id="applyAnthro" class="secondary">Apply</button>
        <button id="resetAnthro" class="secondary">Reset</button>
      </div>

      <h3 style="margin:14px 0 6px 0;">Joints to track</h3>
      <div class="jointGrid" id="jointGrid"></div>

      <label style="margin-top:10px;">
        <input type="checkbox" id="teachingMode" />
        Teaching mode (labels mg / R / τ)
      </label>

      <div class="hint">
        • Must open in Safari (not in-app browser).<br/>
        • If camera fails: aA → Website Settings → Camera → Allow.<br/>
        • iOS may negotiate FPS down; we show actual FPS.
      </div>
    </div>

    <div class="panel">
      <div id="videoWrap">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="overlay"></canvas>
      </div>

      <h3 style="margin:12px 0 6px 0;">Live joint table</h3>
      <table>
        <thead>
          <tr><th>Joint</th><th>Angle (°)</th><th>Vel (°/s)</th><th>τ (Nm)</th></tr>
        </thead>
        <tbody id="kinBody"></tbody>
      </table>

      <p class="interp" id="interpText">Waiting for pose...</p>
    </div>
  </div>

  <script type="module">
    // =========================
    // UI refs
    // =========================
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const startCamBtn = document.getElementById('startCam');
    const stopCamBtn  = document.getElementById('stopCam');
    const exportPNGBtn= document.getElementById('exportPNG');

    const startRecBtn = document.getElementById('startRec');
    const stopRecBtn  = document.getElementById('stopRec');
    const downloadBtn = document.getElementById('downloadCSV');

    const statusText  = document.getElementById('statusText');
    const reqFpsText  = document.getElementById('reqFpsText');
    const actFpsText  = document.getElementById('actFpsText');
    const loopFpsText = document.getElementById('loopFpsText');
    const sampleCount = document.getElementById('sampleCount');
    const fpsNote     = document.getElementById('fpsNote');

    const fpsRequest  = document.getElementById('fpsRequest');
    const securePill  = document.getElementById('securePill');

    const subjectMassInput   = document.getElementById('subjectMass');
    const subjectHeightInput = document.getElementById('subjectHeight');
    const applyAnthroBtn = document.getElementById('applyAnthro');
    const resetAnthroBtn = document.getElementById('resetAnthro');

    const teachingMode = document.getElementById('teachingMode');
    const jointGrid = document.getElementById('jointGrid');

    const kinBody = document.getElementById('kinBody');
    const interpText = document.getElementById('interpText');

    if (window.isSecureContext) {
      securePill.style.display = 'inline-block';
      securePill.textContent = 'HTTPS OK';
    } else {
      securePill.style.display = 'inline-block';
      securePill.className = 'pill bad';
      securePill.textContent = 'NOT HTTPS';
    }

    // =========================
    // State
    // =========================
    let stream = null;
    let loopRunning = false;
    let recording = false;

    let samples = [];
    let lastAngles = {};
    let lastTime = null;

    let focusJoint = 'Torso';

    // loop FPS counter
    let fpsLastT = performance.now();
    let fpsFrames = 0;

    // =========================
    // Joint selection
    // =========================
    const JOINTS = [
      'Torso',
      'L_Shoulder','R_Shoulder',
      'L_Elbow','R_Elbow',
      'L_Wrist','R_Wrist',
      'L_Hip','R_Hip',
      'L_Knee','R_Knee',
      'L_Ankle','R_Ankle'
    ];
    const DEFAULT_SELECTED = new Set(JOINTS);

    function buildJointSelector(){
      jointGrid.innerHTML = '';
      for(const j of JOINTS){
        const id = `j_${j}`;
        const wrap = document.createElement('label');
        wrap.style.margin = '0';
        wrap.innerHTML = `<input type="checkbox" id="${id}" value="${j}" ${DEFAULT_SELECTED.has(j)?'checked':''} /> ${j}`;
        jointGrid.appendChild(wrap);
      }
    }
    buildJointSelector();
    function selectedJoints(){
      return [...jointGrid.querySelectorAll('input[type=checkbox]:checked')].map(x=>x.value);
    }

    // =========================
    // Anthropometrics from mass/height
    // =========================
    let anthro = {
      subjectMass: 70,
      subjectHeight: 1.75,
      upperArmL: 0.188 * 1.75,
      forearmL: 0.146 * 1.75,
      upperArmM: 0.028 * 70,
      forearmM: 0.016 * 70,
      upperArmCOM: 0.188 * 1.75 * 0.436,
      forearmCOM: 0.146 * 1.75 * 0.430,
      upperArmI: 0,
      forearmI: 0
    };

    function applyAnthro(){
      const mass = Number(subjectMassInput.value) || 70;
      const height = Number(subjectHeightInput.value) || 1.75;

      anthro.subjectMass = mass;
      anthro.subjectHeight = height;

      anthro.upperArmL = 0.188 * height;
      anthro.forearmL = 0.146 * height;
      anthro.upperArmM = 0.028 * mass;
      anthro.forearmM = 0.016 * mass;

      anthro.upperArmCOM = anthro.upperArmL * 0.436;
      anthro.forearmCOM = anthro.forearmL * 0.430;

      anthro.upperArmI = (anthro.upperArmM * (anthro.upperArmL**2)) * 0.05;
      anthro.forearmI = (anthro.forearmM * (anthro.forearmL**2)) * 0.04;

      setStatus('Anthro applied');
    }
    function resetAnthro(){
      subjectMassInput.value = 70;
      subjectHeightInput.value = 1.75;
      applyAnthro();
    }
    applyAnthroBtn.addEventListener('click', applyAnthro);
    resetAnthroBtn.addEventListener('click', resetAnthro);
    resetAnthro();

    // =========================
    // OneEuro filter (internal)
    // =========================
    class OneEuroFilter {
      constructor(freq=120, minCutoff=1.0, beta=0.007, dcutoff=1.0){
        this.freq=freq; this.minCutoff=minCutoff; this.beta=beta; this.dcutoff=dcutoff;
        this.xPrev=null; this.dxPrev=0; this.lastTime=null;
      }
      alpha(cutoff){
        const tau = 1.0/(2*Math.PI*cutoff);
        const te = 1.0/this.freq;
        return 1.0/(1.0 + tau/te);
      }
      filter(x, t){
        if(this.lastTime && t){
          const dt = (t-this.lastTime)/1000;
          const safeDt = Math.max(1/300, Math.min(dt, 1/10));
          this.freq = 1.0/safeDt;
        }
        this.lastTime = t || this.lastTime;
        if(this.xPrev===null){ this.xPrev=x; return x; }
        const dx = (x-this.xPrev)*this.freq;
        const eda = this.alpha(this.dcutoff);
        const dxHat = eda*dx + (1-eda)*this.dxPrev;
        const cutoff = this.minCutoff + this.beta*Math.abs(dxHat);
        const ea = this.alpha(cutoff);
        const xHat = ea*x + (1-ea)*this.xPrev;
        this.xPrev=xHat; this.dxPrev=dxHat;
        return xHat;
      }
    }
    const filters = {};
    function getFilter(key){
      if(!filters[key]) filters[key] = new OneEuroFilter(120, 1.0, 0.007, 1.0);
      return filters[key];
    }

    // =========================
    // MediaPipe PoseLandmarker
    // =========================
    let poseLandmarker = null;
    async function initPoseModel(){
      try{
        const { FilesetResolver, PoseLandmarker } =
          await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0');

        const vision = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
        );

        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task'
          },
          runningMode: 'VIDEO',
          numPoses: 1
        });

        setStatus('Pose model ready');
      }catch(err){
        console.error(err);
        poseLandmarker = null;
        setStatus('Pose model failed to load (camera can still run)');
      }
    }
    await initPoseModel();

    // =========================
    // Camera: iOS reliable start
    // (Start with video:true, then apply constraints)
    // =========================
    function resizeCanvasToVideo(){
      const w = video.videoWidth || overlay.clientWidth || 1280;
      const h = video.videoHeight || overlay.clientHeight || 720;
      overlay.width = w;
      overlay.height = h;
    }

    function updateNegotiatedFpsUI(requested, actual){
      reqFpsText.textContent = String(requested);
      actFpsText.textContent = (actual ?? '--');

      const req = Number(requested);
      const act = Number(actual);

      if(!Number.isFinite(act)){
        fpsNote.textContent = 'Actual FPS unknown (browser did not report frameRate).';
        return;
      }
      if(act >= req){
        fpsNote.textContent = `Negotiated at ${act} fps.`;
      }else{
        fpsNote.textContent = `iOS Safari negotiated down to ${act} fps (requested ${req}).`;
      }
    }

    async function startCameraIOSReliable(){
      setStatus('Starting camera...');

      // Stop old stream
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }

      // Strong preflight checks
      if(!navigator.mediaDevices?.getUserMedia){
        throw new Error('getUserMedia not supported on this browser');
      }

      // 1) Get ANY camera first (most reliable on iOS Safari)
      stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });

      // 2) Attach to video before play (iOS picky)
      video.muted = true;
      video.autoplay = true;
      video.playsInline = true;
      video.setAttribute('playsinline','');
      video.setAttribute('muted','');
      video.setAttribute('autoplay','');

      video.srcObject = stream;

      // Wait for metadata
      await new Promise((resolve)=>{
        if(video.readyState >= 1) return resolve();
        video.onloadedmetadata = () => resolve();
      });

      resizeCanvasToVideo();

      // Must be inside a user gesture (Start button click)
      await video.play();

      // 3) Now request "better" constraints (may fail, but keep camera anyway)
      const requested = Number(fpsRequest.value) || 120;
      const track = stream.getVideoTracks()[0];

      try {
        await track.applyConstraints({
          advanced: [
            { facingMode: "environment" },
            { frameRate: { ideal: requested, max: requested } },
            { width: { ideal: 1280 }, height: { ideal: 720 } }
          ]
        });
      } catch (e) {
        console.warn("applyConstraints failed:", e.name, e.message);
        // keep going, stream still valid
      }

      // 4) Show negotiated FPS
      const settings = track.getSettings ? track.getSettings() : {};
      updateNegotiatedFpsUI(requested, settings.frameRate ?? null);

      setStatus('Camera running');
    }

    async function stopCamera(){
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }
      actFpsText.textContent = '--';
      fpsNote.textContent = '';
      setStatus('Camera stopped');
    }

    // =========================
    // Recording
    // =========================
    startRecBtn.addEventListener('click', ()=>{
      if(!stream){ setStatus('Start camera first'); return; }
      recording = true;
      samples = [];
      sampleCount.textContent = '0';
      setStatus('Recording... (camera continues)');
    });

    stopRecBtn.addEventListener('click', ()=>{
      recording = false;
      setStatus(`Recording stopped (${samples.length} samples)`);
    });

    // =========================
    // PNG snapshot
    // =========================
    exportPNGBtn.addEventListener('click', ()=>{
      exportPNGSnapshot();
    });

    function exportPNGSnapshot(){
      if(video.readyState < 2){
        setStatus('PNG export: video not ready');
        return;
      }
      const w = video.videoWidth || overlay.width;
      const h = video.videoHeight || overlay.height;

      const out = document.createElement('canvas');
      out.width = w;
      out.height = h;
      const octx = out.getContext('2d');

      octx.drawImage(video, 0, 0, w, h);
      octx.drawImage(overlay, 0, 0, w, h);

      // stamp
      octx.font = '16px system-ui';
      octx.fillStyle = 'rgba(15,23,42,0.55)';
      octx.fillRect(8, 8, 420, 28);
      octx.fillStyle = 'rgba(226,232,240,0.95)';
      octx.fillText(`Jun Wei Biodynamic Lab • ${new Date().toLocaleString()}`, 14, 28);

      const iso = new Date().toISOString().replace(/[:.]/g,'-');
      const filename = `JunWeiBiodynamicLab_snapshot_${iso}.png`;

      out.toBlob((blob)=>{
        if(!blob){ setStatus('PNG export failed'); return; }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        setStatus('PNG snapshot exported');
      }, 'image/png');
    }

    // =========================
    // Kinematics helpers
    // =========================
    const kpNames = [
      'nose','leftEyeInner','leftEye','leftEyeOuter','rightEyeInner','rightEye','rightEyeOuter','leftEar','rightEar','mouthLeft','mouthRight',
      'leftShoulder','rightShoulder','leftElbow','rightElbow','leftWrist','rightWrist','leftPinky','rightPinky','leftIndex','rightIndex','leftThumb','rightThumb',
      'leftHip','rightHip','leftKnee','rightKnee','leftAnkle','rightAnkle','leftHeel','rightHeel','leftFootIndex','rightFootIndex'
    ];
    const idx = n => kpNames.indexOf(n);

    function angleBetween3D(a,b,c){
      const v1 = {x:a.x-b.x, y:a.y-b.y, z:(a.z||0)-(b.z||0)};
      const v2 = {x:c.x-b.x, y:c.y-b.y, z:(c.z||0)-(b.z||0)};
      const dot = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
      const m1 = Math.hypot(v1.x,v1.y,v1.z);
      const m2 = Math.hypot(v2.x,v2.y,v2.z);
      if(m1===0||m2===0) return NaN;
      let cos = dot/(m1*m2); cos = Math.max(-1, Math.min(1, cos));
      return Math.acos(cos)*180/Math.PI;
    }

    function torsoAngleDeg(lm){
      const lSh = lm[idx('leftShoulder')], rSh = lm[idx('rightShoulder')];
      const lHip = lm[idx('leftHip')], rHip = lm[idx('rightHip')];
      if(!lSh||!rSh||!lHip||!rHip) return NaN;
      const midSh = {x:(lSh.x+rSh.x)/2, y:(lSh.y+rSh.y)/2};
      const midHip= {x:(lHip.x+rHip.x)/2, y:(lHip.y+rHip.y)/2};
      const vx = midSh.x-midHip.x, vy = midSh.y-midHip.y;
      const mag = Math.hypot(vx,vy);
      if(mag===0) return NaN;
      let cos = (vy*(-1))/mag; cos = Math.max(-1, Math.min(1, cos));
      return Math.acos(cos)*180/Math.PI;
    }

    function updateJoint(key, rawAngle, nowMs, dt){
      const f = getFilter(key);
      const angleSm = f.filter(rawAngle, nowMs);
      const prev = lastAngles[key] || {angle:angleSm, vel:0};
      const vel = (isFinite(angleSm) && isFinite(prev.angle)) ? (angleSm - prev.angle)/dt : 0;
      const accel = (isFinite(vel) && isFinite(prev.vel)) ? (vel - prev.vel)/dt : 0;
      lastAngles[key] = {angle:angleSm, vel};
      return {angle:rawAngle, angleSm, vel, accel, tau:NaN};
    }

    function inverseDynamicsArm(theta_sh_deg, theta_el_deg, dth_sh, dth_el, ddth_sh, ddth_el){
      const g = 9.80665;
      const ua = anthro.upperArmM, fa = anthro.forearmM;
      const la = anthro.upperArmL;
      const ra = anthro.upperArmCOM, rf = anthro.forearmCOM;
      const Ia = anthro.upperArmI, If = anthro.forearmI;

      const th1 = theta_sh_deg*Math.PI/180, th2 = theta_el_deg*Math.PI/180;
      const d1 = dth_sh*Math.PI/180, d2 = dth_el*Math.PI/180;
      const dd1 = ddth_sh*Math.PI/180, dd2 = ddth_el*Math.PI/180;

      const m11 = Ia + If + ua*ra*ra + fa*(la*la + rf*rf + 2*la*rf*Math.cos(th2));
      const m12 = If + fa*(rf*rf + la*rf*Math.cos(th2));
      const m21 = m12;
      const m22 = If + fa*rf*rf;

      const h = -fa*la*rf*Math.sin(th2);
      const c1 = h*(2*d1*d2 + d2*d2);
      const c2 = h*d1*d1;

      const g1 = ua*g*ra*Math.cos(th1) + fa*g*(la*Math.cos(th1) + rf*Math.cos(th1+th2));
      const g2 = fa*g*rf*Math.cos(th1+th2);

      const tau1 = m11*dd1 + m12*dd2 + c1 + g1;
      const tau2 = m21*dd1 + m22*dd2 + c2 + g2;
      return {tau_shoulder:tau1, tau_elbow:tau2};
    }

    // =========================
    // Drawing: skeleton + FBD
    // =========================
    const SEG = {
      torso: 'rgba(248,250,252,0.95)',
      L_arm: 'rgba(59,130,246,0.95)',
      R_arm: 'rgba(6,182,212,0.95)',
      L_leg: 'rgba(34,197,94,0.95)',
      R_leg: 'rgba(132,204,22,0.95)'
    };
    function drawLine(a,b,color,width=5){
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }
    function drawPoint(p,color='rgba(147,197,253,0.9)',r=3){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(p.x,p.y,r,0,Math.PI*2);
      ctx.fill();
    }
    function drawArrow(x1,y1,x2,y2,label,color){
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      const ang = Math.atan2(y2-y1, x2-x1);
      const head = 7;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2 - head*Math.cos(ang-0.45), y2 - head*Math.sin(ang-0.45));
      ctx.lineTo(x2 - head*Math.cos(ang+0.45), y2 - head*Math.sin(ang+0.45));
      ctx.closePath();
      ctx.fill();
      if(label){
        ctx.font = '12px system-ui';
        ctx.fillText(label, x2+4, y2-4);
      }
    }
    function drawTorqueArc(cx,cy,tau,color){
      if(!isFinite(tau)) return;
      const sign = tau >= 0 ? 1 : -1;
      const r = 18;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      const a0 = sign>0 ? -0.2 : Math.PI+0.2;
      const a1 = sign>0 ? Math.PI-0.2 : 2*Math.PI-0.2;
      ctx.arc(cx,cy,r,a0,a1, sign<0);
      ctx.stroke();
      ctx.fillStyle = color;
      ctx.font = '12px system-ui';
      ctx.fillText('τ', cx + r + 4, cy - 4);
    }

    function jointPointForKey(key, lm){
      switch(key){
        case 'Torso': {
          const LS = lm[idx('leftShoulder')], RS = lm[idx('rightShoulder')];
          const LH = lm[idx('leftHip')], RH = lm[idx('rightHip')];
          if(!LS||!RS||!LH||!RH) return null;
          const midSh = {x:(LS.x+RS.x)/2, y:(LS.y+RS.y)/2};
          const midHip= {x:(LH.x+RH.x)/2, y:(LH.y+RH.y)/2};
          return {x:(midSh.x+midHip.x)/2, y:(midSh.y+midHip.y)/2};
        }
        case 'L_Shoulder': return lm[idx('leftShoulder')];
        case 'R_Shoulder': return lm[idx('rightShoulder')];
        case 'L_Elbow': return lm[idx('leftElbow')];
        case 'R_Elbow': return lm[idx('rightElbow')];
        case 'L_Wrist': return lm[idx('leftWrist')];
        case 'R_Wrist': return lm[idx('rightWrist')];
        case 'L_Hip': return lm[idx('leftHip')];
        case 'R_Hip': return lm[idx('rightHip')];
        case 'L_Knee': return lm[idx('leftKnee')];
        case 'R_Knee': return lm[idx('rightKnee')];
        case 'L_Ankle': return lm[idx('leftAnkle')];
        case 'R_Ankle': return lm[idx('rightAnkle')];
        default: return null;
      }
    }

    function drawSkeletonAndFBD(lm, results){
      ctx.clearRect(0,0,overlay.width,overlay.height);

      const LS = lm[idx('leftShoulder')], RS = lm[idx('rightShoulder')];
      const LE = lm[idx('leftElbow')],    RE = lm[idx('rightElbow')];
      const LW = lm[idx('leftWrist')],    RW = lm[idx('rightWrist')];

      const LH = lm[idx('leftHip')],      RH = lm[idx('rightHip')];
      const LK = lm[idx('leftKnee')],     RK = lm[idx('rightKnee')];
      const LA = lm[idx('leftAnkle')],    RA = lm[idx('rightAnkle')];

      // Skeleton
      if(LS && RS) drawLine(LS, RS, SEG.torso, 5);
      if(LS && LH) drawLine(LS, LH, SEG.torso, 5);
      if(RS && RH) drawLine(RS, RH, SEG.torso, 5);
      if(LH && RH) drawLine(LH, RH, SEG.torso, 5);

      if(LS && LE) drawLine(LS, LE, SEG.L_arm, 5);
      if(LE && LW) drawLine(LE, LW, SEG.L_arm, 5);
      if(RS && RE) drawLine(RS, RE, SEG.R_arm, 5);
      if(RE && RW) drawLine(RE, RW, SEG.R_arm, 5);

      if(LH && LK) drawLine(LH, LK, SEG.L_leg, 5);
      if(LK && LA) drawLine(LK, LA, SEG.L_leg, 5);
      if(RH && RK) drawLine(RH, RK, SEG.R_leg, 5);
      if(RK && RA) drawLine(RK, RA, SEG.R_leg, 5);

      for(const p of [LS,RS,LE,RE,LW,RW,LH,RH,LK,RK,LA,RA]){
        if(p) drawPoint(p);
      }

      const selected = new Set(selectedJoints());
      const showLabels = teachingMode.checked;

      function fbdAtJoint(jointKey, jointPoint, distalPoint, tauVal){
        if(!selected.has(jointKey) || !jointPoint || !distalPoint) return;
        const mgColor = 'rgba(248,250,252,0.95)';
        const rColor  = 'rgba(251,191,36,0.95)';
        const tauColor= 'rgba(244,63,94,0.95)';

        const comX = (jointPoint.x + distalPoint.x)/2;
        const comY = (jointPoint.y + distalPoint.y)/2;

        drawArrow(comX, comY, comX, comY+32, showLabels ? 'mg' : '', mgColor);
        drawArrow(jointPoint.x, jointPoint.y, jointPoint.x, jointPoint.y-28, showLabels ? 'R' : '', rColor);
        drawTorqueArc(jointPoint.x, jointPoint.y, tauVal, tauColor);
      }

      fbdAtJoint('L_Shoulder', LS, LE, results['L_Shoulder']?.tau);
      fbdAtJoint('R_Shoulder', RS, RE, results['R_Shoulder']?.tau);
      fbdAtJoint('L_Elbow', LE, LW, results['L_Elbow']?.tau);
      fbdAtJoint('R_Elbow', RE, RW, results['R_Elbow']?.tau);
      fbdAtJoint('L_Knee', LK, LA, results['L_Knee']?.tau);
      fbdAtJoint('R_Knee', RK, RA, results['R_Knee']?.tau);

      // Focus ring
      const fp = jointPointForKey(focusJoint, lm);
      if(fp){
        ctx.strokeStyle = 'rgba(37,99,235,0.95)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(fp.x, fp.y, 10, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // =========================
    // Interpretation
    // =========================
    function flexionDescriptor(a){
      if(!isFinite(a)) return 'angle not available';
      if(a >= 165) return 'near full extension';
      if(a >= 135) return 'slight flexion';
      if(a >= 95)  return 'moderate flexion';
      if(a >= 60)  return 'deep flexion';
      return 'very deep flexion';
    }
    function speedDescriptor(v){
      if(!isFinite(v)) return 'motion speed unknown';
      const a = Math.abs(v);
      if(a < 5) return 'almost static';
      if(a < 30) return 'slow / controlled';
      if(a < 90) return 'moderate speed';
      return 'fast / ballistic';
    }
    function torqueDescriptor(t){
      if(!isFinite(t)) return 'τ not estimated';
      const m = Math.abs(t);
      if(m < 5) return 'low torque demand';
      if(m < 30) return 'moderate torque demand';
      return 'high torque demand';
    }
    function updateInterpretation(key, r){
      if(!r){ interpText.textContent = 'Waiting for pose...'; return; }
      const a = isFinite(r.angleSm) ? r.angleSm : r.angle;
      const v = r.vel;
      const t = r.tau;

      let txt =
`${key}
Angle ≈ ${isFinite(a)?a.toFixed(1):'--'}° → ${flexionDescriptor(a)}
Vel   ≈ ${isFinite(v)?v.toFixed(1):'--'} °/s → ${speedDescriptor(v)}
τ     ≈ ${isFinite(t)?t.toFixed(2):'--'} Nm → ${torqueDescriptor(t)}
`;
      if(teachingMode.checked){
        if(/Knee|Hip|Ankle/.test(key)){
          txt += `\nTeaching note: Lower-limb force arrows are illustrative unless GRF + full inverse dynamics are added.`;
        } else if(/Shoulder|Elbow|Wrist/.test(key)){
          txt += `\nTeaching note: τ for shoulder/elbow uses a simplified 2-link arm model.`;
        } else if(key === 'Torso'){
          txt += `\nTeaching note: Torso angle is a proxy for trunk lean vs vertical.`;
        }
      }
      interpText.textContent = txt;
    }

    // =========================
    // CSV
    // =========================
    function downloadCSV(){
      if(samples.length === 0){ setStatus('No samples to export'); return; }
      const cols = Object.keys(samples[0]);
      const rows = [cols.join(',')];
      for(const s of samples){
        rows.push(cols.map(k=>{
          const v = s[k];
          if(v === undefined || v === null) return '';
          if(typeof v === 'number') return Number.isFinite(v) ? v.toFixed(6) : '';
          return String(v).replace(/\r?\n/g,' ');
        }).join(','));
      }
      const blob = new Blob([rows.join('\n')], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'JunWeiBiodynamicLab_joints.csv';
      a.click();
      URL.revokeObjectURL(url);
      setStatus(`CSV downloaded (${samples.length} rows)`);
    }
    downloadBtn.addEventListener('click', downloadCSV);

    // =========================
    // Status helper
    // =========================
    let statusTimer = null;
    function setStatus(msg){
      statusText.textContent = msg;
      if(statusTimer) clearTimeout(statusTimer);
      statusTimer = setTimeout(()=>{
        statusText.textContent = (stream?'Camera running':'Idle') + (recording?' • Recording':'');
      }, 1500);
    }

    // =========================
    // Main loop
    // =========================
    async function runLoop(){
      const step = async ()=>{
        if(!loopRunning) return;

        fpsFrames++;
        const tNow = performance.now();
        if(tNow - fpsLastT >= 500){
          const fps = (fpsFrames * 1000) / (tNow - fpsLastT);
          loopFpsText.textContent = fps.toFixed(1);
          fpsFrames = 0;
          fpsLastT = tNow;
        }

        if(video.readyState < 2){
          requestAnimationFrame(step);
          return;
        }

        const now = performance.now();

        if(!poseLandmarker){
          ctx.clearRect(0,0,overlay.width,overlay.height);
          interpText.textContent = 'Pose model not ready. Check internet/CDN.';
          requestAnimationFrame(step);
          return;
        }

        const det = await poseLandmarker.detectForVideo(video, now);
        const pose = (det?.landmarks?.length) ? det.landmarks[0] : null;

        if(pose) processPose(pose, now);
        else{
          ctx.clearRect(0,0,overlay.width,overlay.height);
          interpText.textContent = 'Pose not detected (step back / improve lighting).';
        }

        requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    }

    function processPose(landmarks, now){
      const w = video.videoWidth || overlay.width;
      const h = video.videoHeight || overlay.height;
      const lm = landmarks.map(p=>({x:p.x*w, y:p.y*h, z:p.z}));

      const dtRaw = (now - (lastTime||now))/1000;
      const dt = Math.max(1/300, Math.min(dtRaw, 1/10));
      lastTime = now;

      const results = {};
      results['Torso'] = updateJoint('Torso', torsoAngleDeg(lm), now, dt);

      const LS = lm[idx('leftShoulder')], RS = lm[idx('rightShoulder')];
      const LE = lm[idx('leftElbow')],    RE = lm[idx('rightElbow')];
      const LW = lm[idx('leftWrist')],    RW = lm[idx('rightWrist')];
      const LI = lm[idx('leftIndex')],    RI = lm[idx('rightIndex')];

      const LH = lm[idx('leftHip')],      RH = lm[idx('rightHip')];
      const LK = lm[idx('leftKnee')],     RK = lm[idx('rightKnee')];
      const LA = lm[idx('leftAnkle')],    RA = lm[idx('rightAnkle')];
      const LFI = lm[idx('leftFootIndex')], RFI = lm[idx('rightFootIndex')];

      if(LH && LS && LE) results['L_Shoulder'] = updateJoint('L_Shoulder', angleBetween3D(LH, LS, LE), now, dt);
      if(RH && RS && RE) results['R_Shoulder'] = updateJoint('R_Shoulder', angleBetween3D(RH, RS, RE), now, dt);

      if(LS && LE && LW) results['L_Elbow'] = updateJoint('L_Elbow', angleBetween3D(LS, LE, LW), now, dt);
      if(RS && RE && RW) results['R_Elbow'] = updateJoint('R_Elbow', angleBetween3D(RS, RE, RW), now, dt);

      if(LE && LW && LI) results['L_Wrist'] = updateJoint('L_Wrist', angleBetween3D(LE, LW, LI), now, dt);
      if(RE && RW && RI) results['R_Wrist'] = updateJoint('R_Wrist', angleBetween3D(RE, RW, RI), now, dt);

      if(LS && LH && LK) results['L_Hip'] = updateJoint('L_Hip', angleBetween3D(LS, LH, LK), now, dt);
      if(RS && RH && RK) results['R_Hip'] = updateJoint('R_Hip', angleBetween3D(RS, RH, RK), now, dt);

      if(LH && LK && LA) results['L_Knee'] = updateJoint('L_Knee', angleBetween3D(LH, LK, LA), now, dt);
      if(RH && RK && RA) results['R_Knee'] = updateJoint('R_Knee', angleBetween3D(RH, RK, RA), now, dt);

      if(LK && LA && LFI) results['L_Ankle'] = updateJoint('L_Ankle', angleBetween3D(LK, LA, LFI), now, dt);
      if(RK && RA && RFI) results['R_Ankle'] = updateJoint('R_Ankle', angleBetween3D(RK, RA, RFI), now, dt);

      // Arm torques
      if(results['L_Shoulder'] && results['L_Elbow']){
        const sh = results['L_Shoulder'], el = results['L_Elbow'];
        const inv = inverseDynamicsArm(sh.angleSm, el.angleSm, sh.vel, el.vel, sh.accel, el.accel);
        sh.tau = inv.tau_shoulder;
        el.tau = inv.tau_elbow;
      }
      if(results['R_Shoulder'] && results['R_Elbow']){
        const sh = results['R_Shoulder'], el = results['R_Elbow'];
        const inv = inverseDynamicsArm(sh.angleSm, el.angleSm, sh.vel, el.vel, sh.accel, el.accel);
        sh.tau = inv.tau_shoulder;
        el.tau = inv.tau_elbow;
      }

      drawSkeletonAndFBD(lm, results);

      const selected = selectedJoints();
      kinBody.innerHTML = '';
      for(const j of selected){
        const r = results[j];
        if(!r) continue;
        const tr = document.createElement('tr');
        if(j === focusJoint) tr.classList.add('focused');
        tr.dataset.joint = j;
        tr.innerHTML = `
          <td>${j}</td>
          <td>${isFinite(r.angleSm)?r.angleSm.toFixed(1):'--'}</td>
          <td>${isFinite(r.vel)?r.vel.toFixed(1):'--'}</td>
          <td>${isFinite(r.tau)?r.tau.toFixed(2):'--'}</td>
        `;
        kinBody.appendChild(tr);
      }

      if(!new Set(selected).has(focusJoint)){
        focusJoint = selected[0] || 'Torso';
      }
      updateInterpretation(focusJoint, results[focusJoint]);

      if(recording){
        const row = { timeISO: new Date().toISOString(), timeMs: now };
        for(const j of selected){
          const r = results[j];
          row[`${j}_angle`] = r?.angleSm;
          row[`${j}_vel`]   = r?.vel;
          row[`${j}_tau`]   = r?.tau;
        }
        samples.push(row);
        sampleCount.textContent = String(samples.length);
      }
    }

    // Focus joint by tapping table
    kinBody.addEventListener('click', (e)=>{
      const tr = e.target.closest('tr');
      if(!tr) return;
      focusJoint = tr.dataset.joint || focusJoint;
    });

    // =========================
    // Camera button wiring
    // =========================
    fpsRequest.addEventListener('change', ()=>{
      reqFpsText.textContent = fpsRequest.value;
    });

    startCamBtn.addEventListener('click', async ()=>{
      try{
        await startCameraIOSReliable();

        if(!loopRunning){
          loopRunning = true;
          lastTime = performance.now();
          runLoop();
        }
      }catch(err){
        console.error(err);
        // iOS needs to show the actual error
        alert(`${err.name}: ${err.message}`);
        setStatus(`Camera error: ${err.name}`);
      }
    });

    stopCamBtn.addEventListener('click', async ()=>{
      loopRunning = false;
      await stopCamera();
    });

    // =========================
    // Cleanup / resize
    // =========================
    window.addEventListener('resize', ()=>{
      if(video?.videoWidth) resizeCanvasToVideo();
    });

    window.addEventListener('beforeunload', ()=>{
      try{
        if(stream?.getTracks) stream.getTracks().forEach(t=>t.stop());
        if(poseLandmarker?.close) poseLandmarker.close();
      }catch(_){}
    });
  </script>
</body>
</html>
